---
title: Using Aerospike EE OnDemand Service for PCF
owner: Partners
---

This topic describes how to use Aerospike EE OnDemand Service for Pivotal Cloud Foundry (PCF).

After installing and configuring the Aerospike EE OnDemand Service for PCF tile, developers can create service instances of Aerospike service plans and bind them to their apps using the Cloud Foundry Command Line Interface (cf CLI). Binding an Aerospike service instance to an app provides the app with information it can use to store and retrieve information in an Aerospike database.

When creating an Aerospike service instance, the tile will also create an Aerospike Management Console (AMC) that can be used to monitor the health and activity on the Aerospike cluster.

##<a id='cf-cli'></a>Create and Bind a Service Instance Using the cf CLI

To create an Aerospike service instance using the cf CLI, perform the following steps:

1. Set your API endpoint to the Cloud Controller of your deployment.
    <pre class="terminal">
    $ cf api api.YOUR-SYSTEM-DOMAIN
    Setting api endpoint to api.YOUR-SYSTEM-DOMAIN...
    OK
    API endpoint:  <span>https</span>://api.YOUR-SYSTEM-DOMAIN (API version: 2.59.0)
    Not logged in. Use 'cf login' to log in.
    </pre>

1. Log in to your deployment and select an org and a space.
    <pre class="terminal">
    $ cf login
    API endpoint: <span>https</span>://api.YOUR-SYSTEM-DOMAIN
    Email> user<span>@</span>example.com
    Password>
    </pre>
    
1. List the Marketplace services and locate the Aerospike service. The service plans match the namespaces that have been configured on the Aerospike database.
    <pre class="terminal">
    $ cf marketplace
    Getting services from marketplace in org system / space apps-manager as admin...
    OK

    service                 plans                    description
    aerospike-on-demand     small, medium, large     An enterprise-class NoSQL database providing speed at scale

    TIP:  Use 'cf marketplace -s SERVICE' to view descriptions of individual plans of a given service.
    </pre>

1. Create an instance of the Aerospike service, specifying both the name of the service plan and the name of the service instance. This example uses the `small` plan.
    <pre class="terminal">
    $ cf create-service aerospike-on-demand small YOUR-SERVICE-INSTANCE -c YOUR-EXTRA-CONFIG
    </pre>

    `YOUR-EXTRA-CONFIG` must be well formed `JSON` adhering to the schema [here](schemas/create.schema.json) and can be either inline or a file. At miniumum you must configure cluster_name and one namespace block.

    Example:
    <pre class="terminal">
    cf create-service aerospike-on-demand small my-cluster -c '{"namespaces": [{"name":"test", "storage_type": "memory", "memory_size": "500M"}], "cluster_name": "my-cluster"}'

    [See here](schemas/create.schema.html) for a description of the possible values (based on [the schema](schemas/create.schema.json))


1. Bind the instance to an app, adding a parameter with name `setname`, and set the value to the name of the set in the Aerospike database that this app should use to store its data. 
    <pre class="terminal">
    $ cf bind-service YOUR-APP YOUR-SERVICE-INSTANCE
    Binding service YOUR-SERVICE-INSTANCE to app YOUR-APP in org example / space development as user@example.com...
    OK
    TIP: Use 'cf restage YOUR-APP' to ensure your env variable changes take effect
    </pre>

1. Restage the app for the binding to take effect.
    <pre class="terminal">
    $ cf restage YOUR-APP
    </pre>
    The app now has all the credentials required to connect to the Aerospike database in the `VCAP_SERVICES` environment variable.

##<a id='cf-cli-update'></a>Updating a Service Instance Using the cf CLI

If you have a service running but need to change some of the configuration you may use the `update-service` command. This command also takes extra config but with a slightly different schema.

<pre class="terminal">
$ cf update-service aerospike-on-demand YOUR-SERVICE-INSTANCE -c YOUR-EXTRA-CONFIG
</pre>

[See here](schemas/update.schema.html) for a description of the possible values for an update (based on [the schema](schemas/update.schema.json))
